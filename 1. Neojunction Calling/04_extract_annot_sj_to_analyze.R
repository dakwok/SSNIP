# Title: "Step 4 - Extract Annotated Splicing Junctions to Analyze"
# July 05, 2020 | Darwin Kwok M.S. | University of California San Francisco

# Purpose: Filter splicing junctions (from STAR aligner's SJ.out.tab file) with GTF file
#          that has been filtered for protein coding genes and TPM > 10.

###########################################################################
#  Step 0: Load Packages and Data -----------------------------------------
###########################################################################

rm(list = ls(all.names = TRUE))

library(readxl)
library(tidyverse)
library(ggsci)

directory_in = "PATH_TO_INPUT"
setwd(directory_in)

#  Load Files -------------------------------------------------------------

# Load the sj.annot.ref file generated by the STAR-aligner index
filename_sj  = "sjdbList.fromGTF.out.tab"
dataframe_sj = read_tsv(filename_sj, na = c("", "NA"), col_names = F, col_types = cols(X1 = col_character()))
  
# Load the GTF file generated in Step 3 - transcripts that are protein-coding and have a median TPM > 10
filename_gtf  = "GTF_ProteinCoding_FilterTPM10_20200717"
dataframe_gtf = read_tsv(filename_gtf, na = c("", "NA"), col_names = T, col_types = cols(chr = col_character()))


###########################################################################
#  Step 1: Modify the Column Names of the SJ File -------------------------
###########################################################################
# The SJ file does not have any column names. Therefore, we add them in this step.

colnames(dataframe_sj) = c("chr", "int.start", "int.end", "strand") ;


###########################################################################
#  Step 2: Filter and Retain Splicing Junctions ---------------------------
###########################################################################
# Filter the SJ dataframe with the GTF dataframe that contains all of the protein-coding and expressed genes
start.time = proc.time()

for (i in 1:nrow(dataframe_sj)) {
  
  # Run Progress
  print(i/nrow(dataframe_sj)*100)
  
  # -----------------------------------------------------------------------
  # Iterate through each row and mark splicing junctions to retain --------
  # -----------------------------------------------------------------------
  # FUNCTION slice() lets you index rows by their integer locations. It allows you to select, remove, and duplicate rows.
  # This will allow me to work with each individual row determined by (i) in the for-loop
  dataframe_sj.i = dataframe_sj %>% 
    dplyr::slice(i)
  
  # Define variables for Chromosome, Strand, Start, and End values in the current SJ row
  CHR    = dataframe_sj.i %>% pull(chr)
  STRAND = dataframe_sj.i %>% pull(strand)
  START  = dataframe_sj.i %>% pull(int.start)
  END    = dataframe_sj.i %>% pull(int.end)
  
  # Filter for rows (NR) in the GTF dataframe that has:
  #   1. The same chromosome and strand number as the SJ dataframe
  #   2. Chromosome coverage that spans the entire junction
  NR = dataframe_gtf %>% 
    dplyr::filter(chr == CHR & strand == STRAND) %>% 
    dplyr::filter(start < START & END < end) %>% 
    head(1) %>%
    nrow()
  
  # Generate a new column "retain" for junctions to retain (1) and junctions to omit (0)
  dataframe_sj.i = dataframe_sj.i %>% 
    mutate(retain = ifelse(NR > 0, 1, 0))
  
  if (i == 1) {
    dataframe_sj.edited = dataframe_sj.i}
  else {
    dataframe_sj.edited = dataframe_sj.edited %>% 
      bind_rows(dataframe_sj.i)}
}

RUNTIME = proc.time() - start.time ; # sec 
RUNTIME %>% print() ; 
# Run time = 5734.217

dataframe_sj.retain = dataframe_sj.edited %>% 
  dplyr::filter(retain == 1) %>% 
  mutate(junc.id = paste0("chr", chr, ":", strand, ":", (int.start - 1), "-", int.end)) %>% 
  dplyr::select(junc.id, chr, strand, int.start, int.end)

dataframe_sj.retain %>% pull(chr) %>% table() ; 

###########################################################################
#  Step 3: Output Data ----------------------------------------------------
###########################################################################

directory_output = "PATH_TO_OUTPUT"
setwd(directory_output)

filename_output = "SJ_List_Filtered_by_GTF_ProteinCoding_ExpressedTranscripts_20200623"
write_tsv(dataframe_sj.retain, filename_output, na = "NA", col_names = T, quote_escape = "double")


###########################################################################
#  Appendix: Filter and Retain Splicing Junctions (Faster DK Algorithm) ---
###########################################################################
start.time = proc.time()

for (j in 1:nrow(dataframe_sj)) {
  print(j/nrow(dataframe_sj)*100)
  dataframe_sj.j = dataframe_sj %>%
    dplyr::slice(j)
  
  # Define variables for Chromosome, Strand, Start, and End values in the current SJ row
  CHR    = dataframe_sj.j %>% pull(chr)
  STRAND = dataframe_sj.j %>% pull(strand)
  START  = dataframe_sj.j %>% pull(int.start)
  END    = dataframe_sj.j %>% pull(int.end)
  
  NR = dataframe_gtf %>% 
    dplyr::filter(chr == CHR & strand == STRAND) %>% 
    dplyr::filter(start < START & END < end) %>% 
    head(1) %>%
    nrow()
  if (j == 1) {dataframe_sj.edited.dk = dataframe_sj.j[0]}
  if (NR > 0) {
    
    dataframe_sj.edited.dk = dataframe_sj.edited.dk %>% 
      bind_rows(dataframe_sj.j)
  }
}

RUNTIME = proc.time() - start.time ; # sec 
RUNTIME %>% print()
# Run time = 2947.345

dataframe_sj.retain.dk = dataframe_sj.edited.dk %>% 
  mutate(junc.id = paste0("chr", chr, ":", strand, ":", (int.start - 1), "-", int.end)) %>% 
  dplyr::select(junc.id, chr, strand, int.start, int.end) %>% 
  dplyr::filter(!is.na(dataframe_sj.edited.dk$chr))


